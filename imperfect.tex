In this chapter we generalize our problem to allow for partitioning $C$ into parts
that are not necessarily clone sets.
We then measure how much such a partition differs from a decloning.
For given preference profile we try to find a partition that minimizes this value.

\section{General Problem}

The problem of \textsc{Decloning} turned out to be simple in the sense of $P$ vs. $NP$-hard.
We may suppose that it is caused by too tight requirements imposed on a part of candidate set partition,
namely it being a clone set.
Now we drop this restriction and instead measure how different in some sense a part is from some clone set.
Of course, we require that this measure equals $0$ only for clone sets.

\begin{defn}[clone set error function]
Given a preference profile $P$ over $C$ we say that a function $f: 2^C \rightarrow \mathbb{R}_+\cup\{0\}$
is a clone set error function for $P$ when $f(X) = 0$ iff $X$ is a clone set for $P$.
\end{defn}

Now we can generalize the \textsc{Decloning} problem into \textsc{OptimalDecloning}
where we try to minimize the sum of errors of parts of candidate set partition.


\begin{problem}{OptimalDecloning}
% TODO: function f as a polynomial circuit
	Input: Preference profile $P$ over $C$, clone set error function $f$,
		integer $k$, positive real number $l$.

	Question: Is there a partition of $C$ into $C_1, ..., C_k$ such that $\sum_{i=1}^k f(C_i) \leq l$?
\end{problem}

\begin{thm} \label{optdecl}
	\textsc{OptimalDecloning} is $NP$-complete.
\end{thm}

\begin{lmm} \label{lmmnotrivial}
	Preference profle $P = (\succ_1, ... , \succ_n)$ over $C = \{1, ..., n\}$
	where for each $i=1,...,n$ we have
	$$i \succ_i i+1 \succ_i ... \succ_i n \succ_i 1 \succ_i 2 \succ_i ... \succ_i i-1$$
	has no non-trivial clone sets.
\end{lmm}

\begin{proof}[Proof by contradiction]
Let us consider a non-trivial clone set $X$ for $P$.
It is a contiguous subsequence of preference order $\succ_1$, so $X = \{i,...,j\}$ for some $i,j \in C$.
Clone set $X$ is not trivial, so both $i\neq{j}$ and $X\neq{C}$.
Let us notice that $X$ is not contiguous on the preference order $\succ_{i+1}$.
Subset $X$ is thus not a clone set for $P$.
\end{proof}

\begin{proof}[Proof of theorem \ref{optdecl}]
We will show a reduction from the \textsc{X3C} problem.

We are given set $X$, collection $S$ and integer $n$.
Let us take clone set $C = X$ and function $f:2^C\rightarrow \{0,1,n+1\}$ such that:
$$ f(X) =
\begin{cases}
0, &\text{when} \left\vert{X}\right\vert \in \{1,3n\} \\
1, &\text{when} X \in S \\
n+1, &\text{in other cases}
\end{cases}
$$
Function $f$ is well-defined, because then $\left\vert{X}\right\vert = \not\in \{1,3n\}$.
Let us take preference profile $P$ over $C$ as in lemma \ref{lmmnotrivial}.
Function $f$ is a clone set error function for $P$, because $f(X) = 0$ iff $X$ is a trivial clone set
and preference profile $P$ has no non-trivial clone sets.
Let us take $l=k=n$, what gives us all the inputs necessary for \textsc{OptimalDecloning} problem.
Let us check when the answer to this problem is \textsc{yes}.

No part $X$ of the partition of $C$ can have $f(X)=n+1$, as it itself exceeds limit $l$.
This means that every part $X$ either belongs to $S$ or has $\left\vert{X}\right\vert \in \{1,3n\}$.
In both cases $\left\vert{X}\right\vert \in \{1,3,3n\}$.
When $n>1$ ($n=1$ can be special-cased during the runtime of reduction) we cannot use $3n$-sized parts,
as it yields only one part in partition while $k>1$.

We are left with $\left\vert{X}\right\vert \in \{1,3\}$.
Let us note that due to the specified size $k=n$ of partition and $\left\vert{C}\right\vert = 3n$
the partition can contain only three-element parts.
This means that we may choose $X$ only from $S$.
It is possible to construct a valid partition only when there is an $A \subset S$ satisfying the \textsc{X3C} problem.

In that case we have partition $A$ of candidate set $C$ such that
$$ \sum_{X \in A} f(X) = \sum_{X \in A} 1 = n,$$
so the answer to \textsc{OptimalDecloning} problem is \textsc{yes}
iff the answer to \textsc{X3C} is~\textsc{yes}.
\end{proof}



\section{Specific Error Functions}